Test-Scenario-1:
  id: ts_01
  path: tests/hydratk/lib/network/term/test_ssh_client.jedi
  name: test_ssh_client
  desc: Unit tests for module hydratk/lib/network/term/ssh_client.py
  author: Petr Rasek <bowman@hydratk.org>
  version: 1.0
  
  pre-req: |
    import yodalib.hydratk.lib.network.term.ssh_client as term
    c = term.TestTermClient()
    
  Test-Case-1:
    id: tc_01
    name: connect
    desc: Tests for method connect
  
    Test-Condition-1: 
      id: tco_01
      name: min_param
      desc: Connect with minimum parameters
      test: |
        host = 'localhost'
        c._events = []
        res = c.connect(host)
                         
      validate: |  
        expected = [True, host, 22, True]
        current = [res, c._client.host, c._client.port, c._client.is_connected]
        this.test_result = (current == expected)
        assert (this.test_result == True), 'Expected: {0}, current: {1}'.format(expected, current)  
        events = ['term_before_connect', 'term_after_connect']
        this.test_result = (c._events == events)
        assert (this.test_result == True), 'Expected: {0}, current: {1}'.format(events, c._events)    
        
    Test-Condition-2: 
      id: tco_02
      name: max_param
      desc: Connect with maximum parameters
      test: |
        [host, port, user, passw] = ['localhost', 222, 'hydra', 'password']
        res = c.connect(host, port, user, passw)
                         
      validate: |  
        expected = [True, host, port, user, passw]
        current = [res, c._client.host, c._client.port, c._client.user, c._client.passw]
        this.test_result = (current == expected)
        assert (this.test_result == True), 'Expected: {0}, current: {1}'.format(expected, current)     
        
    Test-Condition-3: 
      id: tco_03
      name: exception
      desc: Connect exception
      test: |
        res = c.connect(host, ex=True)
                         
      validate: |  
        this.test_result = (res == False)
        assert (this.test_result == True), 'Expected exception' 
        
  Test-Case-2:
    id: tc_02
    name: disconnect
    desc: Tests for method disconnect
  
    Test-Condition-1: 
      id: tco_01
      name: disconnect
      desc: Disconnect
      test: |
        c._events = []
        res = c.disconnect()
                         
      validate: |  
        expected = [True, False]
        current = [res, c._client.is_connected]
        this.test_result = (current == expected)
        assert (this.test_result == True), 'Expected: {0}, current: {1}'.format(expected, current) 
        
    Test-Condition-2: 
      id: tco_02
      name: exception
      desc: Disconnect exception
      test: |
        res = c.disconnect(ex=True)
                         
      validate: |  
        this.test_result = (res == False)
        assert (this.test_result == True), 'Expected exception'    
        
  Test-Case-3:
    id: tc_03
    name: exec_command
    desc: Tests for method exec_command     
    
    Test-Condition-1: 
      id: tco_01
      name: no_out
      desc: Command with no output 
      test: |
        c._events = []
        command = 'touch file'
        res, out = c.exec_command(command)
                         
      validate: |  
        expected = [True, None]
        current = [res, out]
        this.test_result = (current == expected)
        assert (this.test_result == True), 'Expected: {0}, current: {1}'.format(expected, current)  
        events = ['term_before_exec_command', 'term_after_exec_command']
        this.test_result = (c._events == events)
        assert (this.test_result == True), 'Expected: {0}, current: {1}'.format(events, c._events) 
        
    Test-Condition-2: 
      id: tco_02
      name: single_row
      desc: Command with single row on output
      test: |
        command = 'which htk'
        res, out = c.exec_command(command)
                         
      validate: |  
        expected = [True, 1]
        current = [res, len(out)]
        this.test_result = (current == expected)
        assert (this.test_result == True), 'Expected: {0}, current: {1}'.format(expected, current)      
        
    Test-Condition-3: 
      id: tco_03
      name: mult_row
      desc: Command with multiple rows on output
      test: |
        command = 'ls -l'
        res, out = c.exec_command(command)
                         
      validate: |  
        expected = [True, True]
        current = [res, len(out) > 1]
        this.test_result = (current == expected)
        assert (this.test_result == True), 'Expected: {0}, current: {1}'.format(expected, current)  
        
    Test-Condition-4: 
      id: tco_04
      name: error_cmd
      desc: Command with error output
      test: |
        command = 'su'
        res, out = c.exec_command(command)
                         
      validate: |  
        expected = [False, 1]
        current = [res, len(out)]
        this.test_result = (current == expected)
        assert (this.test_result == True), 'Expected: {0}, current: {1}'.format(expected, current)     
        
    Test-Condition-5: 
      id: tco_05
      name: user_input
      desc: Command with user input
      test: |
        [command, input] = ['rm -i htk', 'Y']
        res, out = c.exec_command(command, input)
                         
      validate: |  
        expected = [True, None]
        current = [res, out]
        this.test_result = (current == expected)
        assert (this.test_result == True), 'Expected: {0}, current: {1}'.format(expected, current)                            
        
    Test-Condition-6: 
      id: tco_06
      name: exception
      desc: Exec command exception
      test: |
        res, err = c.exec_command(command='error', ex=True)
                         
      validate: |  
        this.test_result = (res == False and err != None)
        assert (this.test_result == True), 'Expected exception'                                                                  